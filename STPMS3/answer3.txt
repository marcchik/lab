Вопросы
1. Назовите принципы ООП. Поясните каждый из них.


Абстра́кция — в объектно-ориентированном программировании это придание объекту характеристик, которые отличают его от всех других объектов, четко определяя его концептуальные границы. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных от деталей их реализации в виде более простых объектов, подобно тому, как функциональная абстракция разделяет способ использования функции и деталей её реализации в терминах более примитивных функций, таким образом, данные обрабатываются функцией высокого уровня с помощью вызова функций низкого уровня. Такой подход является основой объектно-ориентированного программирования. Это позволяет работать с объектами, не вдаваясь в особенности их реализации. В каждом конкретном случае применяется тот или иной подход: инкапсуляция, полиморфизм или наследование. Например, при необходимости обратиться к скрытым данным объекта, следует воспользоваться инкапсуляцией, создав, так называемую, функцию доступа или свойство. Абстракция данных — популярная и в общем неверно определяемая техника программирования. Фундаментальная идея состоит в разделении несущественных деталей реализации подпрограммы и характеристик существенных для корректного ее использования. Такое разделение может быть выражено через специальный «интерфейс», сосредотачивающий описание всех возможных применений программы[1]. С точки зрения теории множеств, процесс представляет собой организацию для группы подмножеств своего множества. См. также Закон обратного отношения между содержанием и объемом понятия.
1.	 
2.	Инкапсуля́ция — свойство языка программирования, позволяющее пользователю не задумываться о сложности реализации используемого программного компонента (что у него внутри?), а взаимодействовать с ним посредством предоставляемого интерфейса (публичных методов и членов), а также объединить и защитить жизненно важные для компонента данные. При этом пользователю предоставляется только спецификация (интерфейс) объекта. Пользователь может взаимодействовать с объектом только через этот интерфейс. Реализуется с помощью ключевого слова: public. Пользователь не может использовать закрытые данные и методы. Реализуется с помощью ключевых слов: private, protected, internal. Инкапсуляция — один из четырёх важнейших механизмов объектно-ориентированного программирования (наряду с абстракцией, полиморфизмом и наследованием). Сокрытие реализации целесообразно применять в следующих случаях: предельная локализация изменений при необходимости таких изменений, прогнозируемость изменений (какие изменения в коде надо сделать для заданного изменения функциональности) и прогнозируемость последствий изменений.
3.	 
4.	Насле́дование — один из четырёх важнейших механизмов объектно-ориентированного программирования (наряду с инкапсуляцией, полиморфизмом и абстракцией), позволяющий описать новый класс на основе уже существующего (родительского), при этом свойства и функциональность родительского класса заимствуются новым классом. Другими словами, класс-наследник реализует спецификацию уже существующего класса (базовый класс). Это позволяет обращаться с объектами класса-наследника точно так же, как с объектами базового класса. Простое наследование: Класс, от которого произошло наследование, называется базовым или родительским (англ. base class). Классы, которые произошли от базового, называются потомками, наследниками или производными классами (англ. derived class). В некоторых языках используются абстрактные классы. Абстрактный класс — это класс, содержащий хотя бы один абстрактный метод, он описан в программе, имеет поля, методы и не может использоваться для непосредственного создания объекта. То есть от абстрактного класса можно только наследовать. Объекты создаются только на основе производных классов, наследованных от абстрактного. Например, абстрактным классом может быть базовый класс «сотрудник вуза», от которого наследуются классы «аспирант», «профессор» и т. д. Так как производные классы имеют общие поля и функции (например, поле «год рождения»), то эти члены класса могут быть описаны в базовом классе. В программе создаются объекты на основе классов «аспирант», «профессор», но нет смысла создавать объект на основе класса «сотрудник вуза».
5.	 
6.	Множественное наследование
7.	 
8.	При множественном наследовании у класса может быть более одного предка. В этом случае класс наследует методы всех предков. Достоинства такого подхода в большей гибкости. Множественное наследование реализовано в C++. Из других языков, предоставляющих эту возможность, можно отметить Python и Эйфель. Множественное наследование поддерживается в языке UML. Множественное наследование — потенциальный источник ошибок, которые могут возникнуть из-за наличия одинаковых имен методов в предках. В языках, которые позиционируются как наследники C++ (Java, C# и др.), от множественного наследования было решено отказаться в пользу интерфейсов. Практически всегда можно обойтись без использования данного механизма. Однако, если такая необходимость все-таки возникла, то, для разрешения конфликтов использования наследованных методов с одинаковыми именами, возможно, например, применить операцию расширения видимости — «::» — для вызова конкретного метода конкретного родителя. Попытка решения проблемы наличия одинаковых имен методов в предках была предпринята в языке Эйфель, в котором при описании нового класса необходимо явно указывать импортируемые члены каждого из наследуемых классов и их именование в дочернем классе. Большинство современных объектно-ориентированных языков программирования (C#, Java, Delphi и др.) поддерживают возможность одновременно наследоваться от класса-предка и реализовать методы нескольких интерфейсов одним и тем же классом. Этот механизм позволяет во многом заменить множественное наследование — методы интерфейсов необходимо переопределять явно, что исключает ошибки при наследовании функциональности одинаковых методов различных классов-предков.
9.	 
10.	Полиморфи́зм — возможность объектов с одинаковой спецификацией иметь различную реализацию. Язык программирования поддерживает полиморфизм, если классы с одинаковой спецификацией могут иметь различную реализацию — например, реализация класса может быть изменена в процессе наследования[1]. Кратко смысл полиморфизма можно выразить фразой: «Один интерфейс, множество реализаций». Полиморфизм — один из четырёх важнейших механизмов объектно-ориентированного программирования (наряду с абстракцией, инкапсуляцией и наследованием). Полиморфизм позволяет писать более абстрактные программы и повысить коэффициент повторного использования кода. Общие свойства объектов объединяются в систему, которую могут называть по-разному — интерфейс, класс. Общность имеет внешнее и внутреннее выражение: внешняя общность проявляется как одинаковый набор методов с одинаковыми именами и сигнатурами (именем методов и типами аргументов и их количеством); внутренняя общность — одинаковая функциональность методов. Её можно описать интуитивно или выразить в виде строгих законов, правил, которым должны подчиняться методы. Возможность приписывать разную функциональность одному методу (функции, операции) называется перегрузкой метода (перегрузкой функций, перегрузкой операций).
11.	 
12.	Формы полиморфизма Edit
13.	Используя Параметрический полиморфизм можно создавать универсальные базовые типы. В случае параметрического полиморфизма, функция реализуется для всех типов одинаково и таким образом функция реализована для произвольного типа. В параметрическом полиморфизме рассматриваются параметрические методы и типы.
14.	 
15.	Параметрические методы. Если полиморфизм включения влияет на наше восприятие объекта, то параметрические полиморфизм влияет на используемые методы, так как можно создавать методы родственных классов, откладывая объявление типов до времени выполнения. Для избежания написания отдельного метода каждого типа применяется параметрический полиморфизм, при этом тип параметров будет являться таким же параметром, как и операнды.
16.	 
17.	Параметрические типы. Вместо того, чтобы писать класс для каждого конкретного типа следует создать типы, которые будут реализованы во время выполнения программы то есть мы создаем параметрический тип. Полиморфизм переопределения. Абстрактные методы часто относятся к отложенным методам. Класс, в котором определен этот метод может вызвать метод и полиморфизм обеспечивает вызов подходящей версии отложенного метода в дочерних классах. Специальный полиморфизм допускает специальную реализацию для данных каждого типа. Полиморфизм-перегрузка - это частный случай полиморфизма. С помощью перегрузки одно и то же имя может обозначать различные методы, причем методы могут различаться количеством и типом параметров, то есть не зависят от своих аргументов. Метод может не ограничиваться специфическими типами параметров многих различных типов.
18.	 

Кратко: 

Инкапсуляция (пакетирование)
►механизм, связывающий вместе данные и код, обрабатывающий эти данные, и сохраняющий их от внешнего воздействия и ошибочного использовани
1) Никто не знает что внутри 2) Никто не может менять данные снаружи

Абстракция подразумевает разделение и независимое рассмотрение интерфейса и реализации
►абстракция - уровень описания/представления модели чего либо

Наследование
►процесс, благодаря которому один объект может наследовать (приобретать) свойства от другого объекта.
► иерархии классов
Student  -> GradStudent

Полиморфизм
►-способность вызывать метод потомка через экземпляр предка
►- способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта
Поддержка полиморфизма осуществляется через виртуальные функции, механизм перегрузки функций и операторов, а также обобщения 



2. Назовите класс .NET, от которого наследуются все классы.

System.Object.

3. Охарактеризуйте открытые методы System.Object.

Метод Описание
1.	bool Equals() Сравнивает две ссылки на объекты в период выполнения, чтобы определить, указывают ли они в точности один и тот же объект. Если две переменные ссылаются на один и тот же объект, возвращается true. В случае размерных типов этот метод возвращает true, если типы переменных идентичны и их значения равны.
2.	int GetHashCodeO Возвращает заданный для объекта хзш-код. Хэш-функции используются в реализации класса, когда хэш-код объекта нужно поместить в хэш-таблицу для повышения производительности.
3.	Type GetType() Используется с методами отражения  для получения информации о типе данного объекта.
4.	string ToString Используется по умолчанию для получения имени объекта. Его можно переопределить в производных классах, чтобы они возвращали понятное пользователю текстовое представление объекта.


4. Охарактеризуйте закрытые  методы System.Object.

Метод Описание
1.	void Finalize() Вызывается в период выполнения для освобождение ресурсов перед сбором мусора. Этот метод можно вызывать, а можно и не делать этого. Поэтому не помещайте в него подлежащий исполнению код. Это правило выливается в нечто под названием детерминированное завершение (deterministic finalization), о котором подробнее см. главу 5.
2.	Object MemberwiseClone Представляет ограниченную копию (shallow copy) объекта. Под этим я понимаю копию объекта, содержащую ссылки на другие объекты, но не копии этих объектов. Если ваши классы должны поддерживать полную копию (deep copy), которая действительно включает копии объектов, на которые она ссылается, то вам нужно реализовать интерфейс ICloneable и самому вручную производить клонирование или копирование


5. Приведите пример определения класса.

class Employee {
private long employeeld;
}

Как видите, этот простейший класс с именем Employee содержит единственный член — employeeld. Заметьте: имени члена предшествует ключевое слово private — это модификатор доступа (access modifier).


6. Какие ключевые слова можно использовать при определении класса?

Классы объявляются с помощью ключевого слова class, как показано в следующем примере:

public class Customer
{
//Fields, properties, methods and events go here...
}
Ключевому слову class предшествует уровень доступа. Поскольку в этом случае используется открытый класс (public), любой пользователь может создавать объекты из этого класса. За именем класса следует ключевое слово class. Оставшаяся часть определения — это тело класса, в котором задаются данные и поведение. Поля, свойства, методы и события в классе собирательно называются членами класса.



7. В чем отличие между объектом и классом?

Определение класса или структуры подобно чертежу, на котором указаны действия, выполняемые типом. В сущности, объект является блоком памяти, выделенной и настроенной в соответствии с чертежом. Программа может создать множество объектов одного класса. Объекты также называют экземплярами. Они могут храниться либо в именованной переменной, либо в массиве или коллекции. Клиентский код — это код, использующий эти переменные для вызова методов и доступа к открытым свойствам объекта. В объектно-ориентированном языке, таком как C#, стандартная программа состоит из нескольких динамически взаимодействующих объектов.
1.	 
2.	Класс — это конструкция, которая позволяет создавать собственные настраиваемые типы путем группирования переменных других типов, методов и событий. Класс похож на проект. Он определяет данные и поведение типа. Если класс не объявлен как статический, клиентский код может использовать его, создавая объекты или экземпляры, назначенные переменной. Переменная остается в памяти до тех пор, пока все ссылки на нее не выйдут из области. В этот момент среда CLR помечает ее пригодной для сборки мусора. Если класс объявляется как статический, то в памяти существует только одна копия, и клиентский код может получать к ней доступ только через сам класс, а не переменную экземпляра.


8. Что такое конструктор? Когда вызывается конструктор?

Конструктор инициализирует объект при его создании. У конструктора такое же имя, как и у его класса, а с точки зрения синтаксиса он подобен методу. Но у конструкторов нет возвращаемого типа, указываемого явно. Ниже приведена общая форма конструктора:
 
доступ имя_класса(список_параметров) {
// тело конструктора
}
Как правило, конструктор используется для задания первоначальных значений переменных экземпляра, определенных в классе, или же для выполнения любых других установочных процедур, которые требуются для создания полностью сформированного объекта. Кроме того, доступ обычно представляет собой модификатор доступа типа public, поскольку конструкторы зачастую вызываются в классе. А список_параметров может быть как пустым, так и состоящим из одного или более указываемых параметров.

Каждый класс C# снабжается конструктором по умолчанию, который при необходимости может быть переопределен. По определению такой конструктор никогда не принимает аргументов. После размещения нового объекта в памяти конструктор по умолчанию гарантирует установку всех полей в соответствующие стандартные значения. Если вы не удовлетворены такими присваиваниями по умолчанию, можете переопределить конструктор по умолчанию в соответствии со своими нуждами.

Конструктор также может принимать один или несколько параметров. В конструктор параметры вводятся таким же образом, как и в метод. Для этого достаточно объявить их в скобках после имени конструктора.



9. Перечислите свойства конструктора?

Свойства конструкторов
►1) не имеет возвращаемого значения
►2) имя такое же как и имя типа (класса)
► 3) не наследуются
► 4) нельзя применять модификаторы virtual, new, override, sealed и abstract
► 5) для класса без явно заданных конструкторов компилятор создает конструктор по умолчанию (без параметров)
6) для статических классов (seald и abstract) компилятор не создает конструктор по умолчанию
► 7) может определяться несколько конструкторов, сигнатуры и уровни доступа к конструкторам обязательно должны отличаться
 8) можно явно заставлять один конструктор вызывать другой конструктор посредством зарезервированного слова this:


10. Что такое деструктор (destructor) ?

Деструктор - это специальный тип метода класса, который выполняется при удалении объекта класса. В то время как конструкторы предназначены для инициализации класса, деструкторы предназначены для очистки памяти после него.

11. Что такое this?

В языке C# имеется ключевое слово this, которое обеспечивает доступ к текущему экземпляру класса. Одно из возможных применений ключевого слова this состоит в том, чтобы разрешать неоднозначность контекста, которая может возникнуть, когда входящий параметр назван так же, как поле данных данного типа. Разумеется, в идеале необходимо просто придерживаться соглашения об именовании, которое не может привести к такой неоднозначности. 

обеспечивает доступ к текущему экземпляру класса ► в любой  нестатический метод автоматически передается скрытый параметр this


12. Что будет выведено в результате выполнения
class A         {             private int _num;             public A(int num) { Num = num; }             public int Num { get { return _num; } set { _num = value; } }         }
 
        static void Main(string[] args)         {             A a = new A(5);             A b = a;             Console.WriteLine(a.Num + " "  +b.Num);                       a.Num = 7;             Console.WriteLine(a.Num + " " + b.Num);         }




13. Какие спецификаторы доступа для класса и методов класса существуют в C#?

Доступ к членам класса осуществляется с помощью следующих спецификаторов доступа: public, private, protected, internal. Здесь я буду рассматривать только public и private. Спецификатор protected используется при включении интерфейсов (наследование), а спецификатор internal используется крайне редко и применяется при использовании компоновочных файлов.
Спецификатор public разрешает доступ к данному члену классу из любой части программы, т.е. другими словами любой метод или член другого класса может получить доступ к члену класса, у которого спецификатор стоит public.
В свою очередь, private запрещает открытый доступ к члену класса, т.е. доступ к нему имеет только члены и методы данного класса. Из других классов получить доступ к данному члену класса (у которого стоит спецификатор доступа private) нельзя.


14. Опишите модификатор protected internal.

protected internal — модификатор доступа, который обозначает, что им помеченное доступно внутри сборки или наследникам класса, в котором расположено помеченное


15. Зачем и как используются ref  и out параметры функции?

Разница в том, что out — это выходной параметр, а ref — входно-выходной.
1.	 
2.	Для ref-параметра вы должны передать его инициализированным, и можете пользоваться его исходным значением. А для out-параметра вы не обязаны инициализировать его перед вызовом функции, не можете использовать его значение в функции до присваивания, и обязаны инициализировать его в функции.


16. Приведите пример необязательных и именованных параметров метода.

Все типы и члены имеют уровень доступности, определяющий возможность их использования из другого кода в вашей или в других сборках. Следующие модификаторы доступа позволяют указать доступность типа или члена при объявлении:
1.	public
2.	Доступ к типу или члену возможен из любого другого кода в той же сборке или другой сборке, ссылающейся на него.
3.	private
4.	Доступ к типу или члену возможен только из кода в том же классе или структуре.
5.	protected
6.	Доступ к типу или члену возможен только из кода в том же классе или структуре либо в классе, производном от этого класса.
7.	internal
8.	Доступ к типу или члену возможен из любого кода в той же сборке, но не из другой сборки.
9.	protected internal
10.	Доступ к типу или члену возможен из любого кода в той сборке, где он был объявлен, или из производного класса в другой сборке. Доступ из другой сборки должен осуществляться в объявлении класса, производного от класса, в котором объявлен защищенный внутренний элемент, и через экземпляр типа производного класса.


17. Приведите пример полей класса –  статические, константные, только для чтения.

Модификатор static используется для объявления статического члена, принадлежащего собственно типу, а не конкретному объекту. Модификатор static можно использовать с классами, полями, методами, свойствами, операторами, событиями и конструкторами, но нельзя — с индексаторами, методами завершения или типами, отличными от классов. Дополнительные сведения см. в статье Статические классы и члены статических классов.
1.	Пример
2.	Следующий класс объявляется как static и содержит только методы static:
3.	C#
4.	 
5.	Копировать
6.	static class CompanyEmployee
7.	{
8.	public static void DoSomething() { /*...*/ }
9.	public static void DoSomethingElse() { /*...*/ }
10.	}
11.	Объявление константы или типа неявно является статическим членом.
12.	 
13.	 
14.	 
15.	Для объявления константного поля или константной локальной используется ключевое слово const. Константные поля и локальные не являются переменными и не могут быть изменены. Константы могут быть числами, логическими значениями, строками или нулевыми ссылками. Не создавайте константу для предоставления сведений, которые могут измениться в любое время. Например, не используйте константное поле для хранения цены услуги, номера версии продукта или торгового названия компании. Эти значения могут со временем измениться, а поскольку константы распространяются компиляторами, для отражения изменений потребуется повторная компиляция остальных кодов, скомпилированных с использованием ваших библиотек. См. также описание ключевого слова readonly. Пример:
16.	C#
17.	 
18.	Копировать
19.	const int x = 0;
20.	public const double gravitationalConstant = 6.673e-11;
21.	private const string productName = "Visual C#";
22.	 
23.	 
24.	Ключевое слово readonly — это модификатор, который можно использовать для полей. Если объявление поля содержит модификатор readonly, присвоение значений таким полям может происходить только как часть объявления или в конструкторе в том же классе.
25.	Пример
26.	В этом примере значение поля year нельзя изменить в методе ChangeYear, несмотря на то, что в конструкторе класса ему присваивается значение:
27.	C#
28.	 
29.	Копировать
30.	class Age
31.	{
32.	readonly int _year;
33.	Age(int year)
34.	{
35.	_year = year;
36.	}
37.	void ChangeYear()
38.	{
//_year = 1967; // Compile error if uncommented.
}
}


18. Приведите пример определения свойств класса. Как свойства связаны с инкапуляцией?

Свойства – специальные методы класса, служат для организации доступа к полям класса. ►Как правило, свойство связано с закрытым полем класса и определяет методы его получения и установки  (предоставляет инкапсуляцию).
►Синтаксис свойства:
[атрибуты]  [спецификаторы]  тип имясвойства
 { [get код_доступа] [set код_доступа] }

19. Назовите явное имя параметра, передаваемого в метод set свойства класса?

value. Тип этого параметра определяется типом свойства.

20. Что такое автоматические свойства?

Автоматическое свойство – это очень простое свойство, которое, в отличии от обычного свойства, уже определяет место в памяти. C#.

Имеют сокращенное объявление: имя_свойства{get; set;}

компилятор автоматически реализует методы для правильного возвращения значения из поля и назначения значения полю

21. Что такое индексаторы класса? Какие ограничения существуют на индексатор?

Индексаторы (свойства с параметрами)
►Позволяют индексировать объекты таким же способом, как массив или коллекцию ►«умный» индекс для объектов
►средство, позволяющее разработчику перегружать оператор []

Ограничения на индексаторы:
1) значение, выдаваемое индексатором, нельзя передавать методу в качестве параметра ref или out
2) индексатор не может быть объявлен как static

22. Что такое  перегруженный метод?

Перегрузка методов – это объявление в классе методов с одинаковыми именами при этом с различными параметрами. Имея некий метод, чтобы его перегрузить, другой метод с таким же именем должен отличаться от него количеством параметров и/или типами параметров.

23. Что такое partial класс и какие его преимущества?

Частичные классы (partial class) представляют возможность разделить функционал одного класса на несколько файлов. Например, сейчас у нас код класса Book весь находится в одном файле Book.cs. Но мы можем разделить весь код на несколько разных файлов. В этом случае нам надо будет поставить перед определением класса ключевое слово partial. Допустим в одном файле будет:

1.	partial class Book
2.	{
3.	public string name;
4.	public string author;
5.	public int year;
6.	}
7.	А в другом файле будет:


8.	partial class Book
9.	{
10.	public Book(string name, string author, int year)
11.	{
12.	this.name = name;
13.	this.author = author;
14.	this.year = year;
15.	}

16.	public void GetInformation()
17.	{
18.	Console.WriteLine("Книга '{0}' (автор {1}) была издана в {2} году", name, author, year);
19.	}
20.	}
 
Преимущество в том, что можно разделять код на несколько частей и тот будет работать как надо.


24. Что такое анонимный тип в C#?

Анонимные типы позволяют создать объект с некоторым набором свойств без определения класса. Анонимный тип определяется с помощью ключевого слова var и инициализатора объектов:

var user = new { Name = "Tom", Age = 34 };
Console.WriteLine(user.Name);

В данном случае user - это объект анонимного типа, у которого определены два свойства Name и Age. И мы также можем использовать его свойства, как и у обычных объектов классов. Однако тут есть ограничение - свойства анонимных типов доступны только для чтения.

При этом во время компиляции компилятор сам будет создавать для него имя типа и использовать это имя при обращении к объекту. Нередко анонимные типы имеют имя наподобие "<>f__AnonymousType0'2".

Для исполняющей среды CLR анонимные типы будут также, как и классы, представлять ссылочный тип.

Если в программе используются несколько объектов анонимных типов с одинаковым набором свойств, то для них компилятор создаст одно определение анонимного типа:

var user = new { Name = "Tom", Age = 34 };
1.	var student = new { Name = "Alice", Age = 21 };
2.	var manager = new { Name = "Bob", Age = 26, Company = "Microsoft" };
3.	 
4.	Console.WriteLine(user.GetType().Name); // <>f__AnonymousType0'2
5.	Console.WriteLine(student.GetType().Name); // <>f__AnonymousType0'2
6.	Console.WriteLine(manager.GetType().Name); // <>f__AnonymousType1'3
7.	Здесь user и student будут иметь одно и то же определение анонимного типа. Однако подобные объекты нельзя преобразовать к какому-нибудь другому типу, например, классу, даже если он имеет подобный набор свойств.
8.	 
9.	Зачем нужны анонимные типы? Иногда возникает задача использовать один тип в одном узком контексте или даже один раз. Создание класса для подобного типа может быть избыточным. Если нам захочется добавить свойство, то мы сразу же на месте анонимного объекта это можем сделать. В случае с классом придется изменять еще и класс, который может больше нигде не использоваться. Типичная ситуация - получение результата выборки из базы данных: объекты используются только для получения выборки, часто больше нигде не используются, и классы для них создавать было бы излишне. А вот анонимный объект прекрасно подходит для временного хранения выборки.
10.	 


25. Для чего делают статические классы?

Cтатический класс в основном такой же, как и нестатический класс, но имеется одно отличие: нельзя создавать экземпляры статического класса. Другими словами, нельзя использовать ключевое слово new для создания переменной типа класса. Поскольку нет переменной экземпляра, доступ к членам статического класса осуществляется с использованием самого имени класса. 
Ниже приведены основные возможности статического класса.
1.	Содержит только статические члены.
Создавать его экземпляры нельзя.
Является запечатанным.
Не может содержать конструкторы экземпляров.
По сути, создание статического класса аналогично созданию класса, содержащего только статические члены и закрытый конструктор. Закрытый конструктор не допускает создания экземпляров класса. Преимущество применения статических классов заключается в том, что компилятор может проверить отсутствие случайно добавленных членов экземпляров. Таким образом, компилятор гарантирует невозможность создания экземпляров таких классов.
2.	Статические классы запечатаны, поэтому их нельзя наследовать. Они не могут наследовать ни от каких классов, кроме Object. Статические классы не могут содержать конструктор экземпляров, но могут содержать статический конструктор. Нестатические классы также должен определять статический конструктор, если класс содержит статические члены, для которых нужна нетривиальная инициализация.





26. В чем отличие статического поля от экземплярного?

Статический метод - вызывается на уровне типа (вызов: Имя_типа точка Имя_метода)
Экземплярный метод - вызывается на уровне объявленного экземпляра типа (вызов: Имя_переменной точка Имя_метода).


27. Поясните работу статических конструкторов.

Статический конструктор используется для инициализации любых статических данных или для выполнения определенного действия, которое требуется выполнить только один раз. Он вызывается автоматически перед созданием первого экземпляра или ссылкой на какие-либо статические члены. 

Статические конструкторы обладают следующими свойствами.
1.	Статический конструктор не принимает модификаторы доступа и не имеет параметров.
2.	Статический конструктор вызывается автоматически для инициализации класса перед созданием первого экземпляра типа или ссылкой на какие-либо статические члены.
3.	Статический конструктор нельзя вызывать напрямую.
4.	Пользователь не управляет временем, в течение которого статический конструктор выполняется в программе.
5.	Типичным использованием статических конструкторов является случай, когда класс использует файл журнала и конструктор применяется для добавления записей в этот файл.
6.	Статические конструкторы также полезны при создании классов-оболочек для неуправляемого кода, когда конструктор может вызвать метод LoadLibrary.
7.	Если статический конструктор инициирует исключение, среда выполнения не вызывает его во второй раз, и тип остается неинициализированным на время существования домена приложения, в котором выполняется программа.


28. Какая разница между поверхностным (shallow) и глубоким (deep) копированием?

При поверхностном копировании копируются значения полей класса, включая значения любых указателей или ссылок. При этом скопированные значения этих указателей и ссылок указывают на одни и те же объекты, что и в оригинальном объекте, что зачастую ведет к ошибкам. Отсюда и название такого метода копирования: мы копируем только указатели/ссылки, вместо того, чтобы делать копии этих внутренних объектов и ссылаться на них, собственно не углубляемся во внутреннюю структуру объекта. При глубоком копировании мы копируем значения полей не только на первом "уровне", но и заходим глубже, копируя все значения.

29. В чем разница между равенством и тождеством объектов?

Понятие и знак "равно" используют:
а) для записи верных числовых равенств, например, 3+2=5.
б) для записи уравнений, т. е. соотношений, содержащих переменные
величины, причем такое соотношение может быть верным при
некоторых значениях переменных, называемых решениями (или
корнями) уравнения. Например, 3х=9 верно при х=3.

Понятие "тождество" (или тождественное равенство, обозначают
тремя черточками) означает равенство, содержащее переменные
величины, причем это равенство должно быть верным при всех
(допустимых) значениях переменных, например, 3(х+у) =3х+3у.


30. Что такое частичные классы и частичные методы?

В языке C# возможно разбиение определения класса, структуры или интерфейса между двумя или больше исходными файлами. Каждый исходный файл содержит свою часть определения класса и все такие части собираются во время компиляции.
Есть несколько ситуаций, когда удачно разбить определение класса на несколько файлов:
При работе над большим проектом, разбиение класса на несколько файлов позволяет нескольким программистам работать над ним одновременно.
 При работе с автоматически генерируемыми исходниками, код может быть добавлен в класс без необходимости пересоздавать исходник. Visual Studio использует этот подход при создании компонентов Windows Forms, веб-сервисов и т.д. Возможно создать код, который использует эти классы без необходимости редактировать файлы, которые создает Visual Studio.

Для такого разбития класса используется модификатор partial.

Частичные методы обычно используются кодогенераторами. Они объявляются в автоматически сгенерированной части кода и оттуда же вызваются, а в части кода, которая пишется вручную, их можно реализовать. Если метод не реализован, при компиляции его вызовы автоматически удаляются из кода. Соответственно, сигнатура этих методов должна быть такой, чтобы их удаление никак не повлияло на собираемость кода. Отсюда описанные ограничения.


31. Что будет выведено на консоль результате выполнения следующего  кода:
 









Тип неявно типизированной переменной age: int



32. Что будет выведено на консоль результате выполнения следующего  кода:
 using System;
class HelloWorld {
    
  static void Main() {
      int a =1; b=2;
      change(ref a, ref b);
      Console.WriteLine("a=" +a+", b="+b);
      Console.ReadLine();
   
  }
  
  private static void change(ref itn a, ref int b)
  {
      int c = a;
      a=b;
      b=c;
      
  }
а= 2, b=1

С помощью ref мы получаем ссылку на значение переменной, а не ее копию

33. Пусть задан следующий класс.

 





Какой из конструкторов задан неверно? 

Второй, потому что у конструктора нет типа.

34. Пусть задан следующий класс.

 
Сколько аргументов может быть задано при вызове конструктора данного класса?

Два, один, ноль(?)

35. Почему не удается создать объект класса A?


 








Так как первые три конструктора приватные, а для использования последнего нужно в скобках указать два параметра.


36. Что будет выведено в консоль при выполнении данной программы?
 




 







A
Так как первое приватное(закрытый конструктор(?))





37. Какая строка приведенного далее класса вызовет ошибку компиляции?  
 
















Третье(b), так как доступное только для чтения статистическое поле можно инициилизировать только в статистичеком конструкторе и инициализаторе переменных.
